### 使用

```css
/* index.css */
@import "./test.css";

.title {
  color: red;
}
```

```css
.title {
  transition: all 0.5s;
  user-select: none;
  background: linear-gradient(to bottom, white, black);
}
```

这个时候打包，可以成功，但是没有自动加前缀，下面是解释：

1. index.css @import 语句导入了 test.css
2. index.css 被匹配，postcss-loader 进行工作
3. postcss-loader 拿到 index.css 发现没有需要处理的文件（加前缀）
4. 将代码直接给了 css-loader
5. css-loader 可以处理 @import media url ... ，这个时候它拿到了 test.css，但是 loader 不会回头找了
6. 最终将处理好的 css 代码交给 style-loader 进行展示

### 解决问题

```js
module.exports = {
  plugins: [require("postcss-preset-env")],
};
```

```js
// webpack.config.js
const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "build.js", // 打包结果的文件名称
    path: path.resolve(__dirname, "dist"), // 路径，只能是绝对路径
  },
  module: {
    rules: [
      // {
      //   test: /\.css$/, // 一般就是一个正则表达式，用于匹配要处理的文件类型, \是转移， $表示结尾
      //   use: [
      //     {
      //       loader: "css-loader", // 表示要用的loader
      //       // options: // 字符串或着对象，可选参数，用户传进来特定的配置参数
      //       // query: // webpack5 里已经合并到options里面了
      //     },
      //   ],
      // },
      // {
      //   test: /\.css$/,
      //   loader: 'css-loader'
      // },    // 上面的简写，只有一个loader，且没有什么配置参数，完全可以简写
      {
        test: /\.css$/,
        use: [
          "style-loader",
          {
            loader: "css-loader",
            options: {
              importLoaders: 1, // css-loader处理过程中，发现有其它css文件时，向前找一个loader（postcss-loader），如果想找更多的就增加数字
            },
          },
          "postcss-loader",
        ], // 执行顺序是从后向前
      }, // 另一种简写形式，有多个loader，并且不需要配置参数
      {
        test: /\.less$/,
        // 因为配置文件提取到了 postcss.config.js 中（0005.md），所以 "postcss-loader" 直接写在这就可以了
        use: ["style-loader", "css-loader", "postcss-loader", "less-loader"], // 执行顺序是从后向前
      },
    ],
  },
};
```

上面代码修改了，这个地方

```js
{
  loader: "css-loader",
  options: {
    importLoaders: 1  // css-loader处理过程中，发现有其它css文件时，向前找一个loader（postcss-loader），如果想找更多的就增加数字
  }
},
```
