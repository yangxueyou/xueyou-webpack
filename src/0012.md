### babel 使用

1. 为什么需要 babel

类似于 postcss，处理 js 的兼容

比如我们项目是 react，里面有 `jsx，ts，es6+` 等等语法，浏览器默认情况下是`不能直接识别的`，

babel-loader 就是使用 babel

2. 安装使用

```js
// babel7之后就是微内核，核心操作(也就是转换)都放在了core中了
// 想实现具体功能的转换还需要安装对应的内容，比如 作用域，尖头函数，class，类的修饰符等等
$ npm i -D @babel/core

// 上面命令也是不能在命令行中使用，需要安装cli
$ npm i -D @babel-cli
// 编译src下所有的js文件，输出到build下，发现语法没有变
$ npx babel src --out-dir build
```

```js
// 上面@babel/core 只是转换，并不能翻译 箭头函数，需要我们单独安装一个包帮助翻译
$ npm i -D @babel/plugin-transform-arrow-functions
// 在输出目录下，发现尖头函数被翻译成了function
$ npx babel src --out-dir build --plugin=@babel/plugin-transform-arrow-functions

// 把 const，let 转换成 var
$ npm i -D @babel/plugin-transform-block-scoping
// 发现文件里的 const和尖头函数都被翻译成 es5了
$ npx babel src --out-dir build --plugin=@babel/plugin-transform-arrow-functions,@babel/plugin-transform-block-scoping
```

3. @babel/preset-env

发现上面每次需要转的东西，都需要一个一个的找，非常麻烦,

@babel/preset-env 是一个`集合`

```js
$ npm i -D @babel/preset-env
// 使用集合，就不需要一个一个指定 plugin了
$ npx babel src --out-dir build --presets=@babel/preset-env
```

### babel-loader

```js
$ npm i -D babel-loader
```

```js
// webpack.config.js
const path = require("path");
const { DefinePlugin } = require("webpack"); // 暴露全局常量
const { CleanWebpackPlugin } = reuqire("clean-webpack-plugin"); // 清空打包目录
const HtmlWebpackPlugin = require("html-webpack-plugin"); // 自动生成html

module.exports = {
  mode: "development",
  entry: "./src/index.js",
  output: {
    filename: "build.js", // 打包结果的文件名称
    path: path.resolve(__dirname, "dist"), // 路径，只能是绝对路径
    // assetModuleFilename: "img/[name].[hash:4][ext]", // asset模块使用，这是全局配置，可能字体也使用 asset 模块
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader",
          {
            loader: "css-loader",
            options: {
              importLoaders: 1, // css-loader处理过程中，发现有其它css文件时，向前找一个loader（postcss-loader），如果想找更多的就增加数字
              esModule: false, // 否则加载背景图片失败
            },
          },
          "postcss-loader",
        ], // 执行顺序是从后向前
      }, // 另一种简写形式，有多个loader，并且不需要配置参数
      {
        test: /\.less$/,
        // 因为配置文件提取到了 postcss.config.js 中（0005.md），所以 "postcss-loader" 直接写在这就可以了
        use: ["style-loader", "css-loader", "postcss-loader", "less-loader"], // 执行顺序是从后向前
      },
      {
        test: /\.(png|svg|gif|jpe?g)$/, // 使用 webpack5 内置模块
        type: "asset", // 根据条件判断使用哪种模式
        generator: {
          filename: "img/[name].[hash:4][ext]",
        },
        parser: {
          dataUrlCondition: {
            maxSize: 30 * 1024, // 大于 30kb 进行拷贝，否则直接打包进代码里
          },
        },
      },
      {
        test: /\.(ttf|woff2?)$/, // iconfront 图标字体
        type: "asset/resource", // 直接作为静态资源拷贝出去就可以了
        generator: {
          filename: "font/[name].[hash:4][ext]",
        },
      },
      {
        test: /\.js$/,
        use: ["babel-loader"] // 使用 babel.config.js 配置文件
        // use: [
        //   {
        //     loader: "babel-loader",
        //     options: {
        //       // plugins: [
        //       //   '@babel/plugin-transform-arrow-functions',
        //       //   '@babel/plugin-transform-block-scoping'
        //       // ]
        //       // presets: ['@babel/preset-env']  // 是否转换取决于什么条件？.browserslistrc 配置文件，建议使用这种形式
        //       presets: [
        //         [
        //           "@babel/preset-env",
        //           {
        //             targets: "chrome 91",
        //           },
        //         ],
        //       ], // 是否转换取决于什么条件？当前的targets
        //     },
        //   },
        // ],
      },
    ],
  },

  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: "test title",
      template: "./public/index.html",
    }),
    new DefinePlugin({
      BASE_URL: '"./"', // 如果只有一个引号，解析出去的就是 ./ ，这样解析的是字符串 './'
    }),
  ],
};
```

### babel-loader 的配置文件

两种形式

- babel.config.js(json cjs mjs) 7 之后使用这个
- babelrc.json(js) babel 之前使用的更多

也可以像 postcss 一样，单独拿出来，做一个配置文件，简化 webpack 中的配置

```js
// babel.config.js

module.exports = {
  presets: ["@babel/preset-env"],
};
```
